<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Swin Transformer论文总结报告</title>
      <link href="/2024/04/12/Swin%20Transformer%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/04/12/Swin%20Transformer%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin Transformer"></a>Swin Transformer</h1><p><img src="/images/picture1.png" alt="图1 Swin Transformer架构图"></p><p>Swin-Transformer在Transformer模块中使用了类似于深度卷积网络的“层次化构建”方法，引入“Patch”的概念，同时修改了网络的Block</p><p>在开始前，Swin-Transformer首先对输入图像做一次Patch Partition+Patch Embedding，之后送入BackBone中。在BackBone里，Feature Map的尺寸逐渐减小，感受野逐渐扩大；同时在一个Block里，Feature Map被一个个Patch分割</p><p>注意，(b)中结构是成对出现的，所以Block的重复次数一定是偶数，它们的Attention模块不同</p><h2 id="1-Patch-Partition"><a href="#1-Patch-Partition" class="headerlink" title="1. Patch Partition"></a>1. Patch Partition</h2><p>input &#x3D; (H, W, 3)，output &#x3D; (H&#x2F;4, W&#x2F;4, 3*16&#x3D;48)，易得Patch Partition是将输入图像做4x4的Patch分割，每张RGB图像有3通道，即得到了48个(H&#x2F;4, W&#x2F;4)大小的输入</p><p><img src="/images/picture2.png" alt="Untitled"></p><h2 id="2-Linear-Embedding"><a href="#2-Linear-Embedding" class="headerlink" title="2. Linear Embedding"></a>2. Linear Embedding</h2><p>通过一层stride &#x3D; kernel_size的卷积层实现，input &#x3D; (H&#x2F;4, W&#x2F;4, 48)，output &#x3D; (H&#x2F;4, W&#x2F;4, C)，这里的C由网络的不同版本类型指定</p><h2 id="3-Patch-Merging"><a href="#3-Patch-Merging" class="headerlink" title="3. Patch Merging"></a>3. Patch Merging</h2><p>如下图，在CNN中，我们通过池化操作来下采样；Swin-Transformer中的Patch Merging操作是将Feature Map分成无数个4x4的Patch，分别提取每个Patch的[0, 0]、[1, 0]、[0, 1]、[1, 1]位置作为新的channel，这样实现尺寸变为原来四分之一，但通道数翻4倍</p><p>这样的好处是可以进行不同window之间的shuffle操作，使得后续的W-MSA、SW-MSA可以实现不同window的信息交流</p><p><img src="/images/picture3.png" alt="Untitled"></p><p>然后再通过Layer Norm，最后接一个Conv1x1将channel再次减半 </p><h2 id="4-W-MSA"><a href="#4-W-MSA" class="headerlink" title="4. W-MSA"></a>4. W-MSA</h2><p>即Windows - Multi-head Self-Attention模块，将特征图分成若干个window，对每个window进行Self-Attention，减小计算量</p><h2 id="5-SW-MSA"><a href="#5-SW-MSA" class="headerlink" title="5. SW-MSA"></a>5. SW-MSA</h2><p>即Shifted Windows - Multi-head Self-Attention模块。为了解决W-MSA中信息交互问题，作者提出通过Shift偏移方式，即将图像向右下偏移$\frac{window_size}{2}$个单位，如下图，则区域自左到右、自上而下被划分为A1、C1、A2、B1、D、B2、A3、C2、A4。此时B、C包含了2个window的信息，D包含了4个window</p><p>但这样，显然不方便计算。因此我们移动新划分的区域，如下图，即可实现新的窗口划分，这样每个window的尺寸就相同了</p><p><img src="/images/picture4.png" alt="Untitled"></p><p><img src="/images/picture5.png" alt="Untitled"></p><p>而为了计算时B1、B2互不干扰，C1、C2互不干扰，因此在每个MSA中做mask操作。掩码操作同Transformer中Decoder的操作，对于对应掩码位置直接减去一个INF（无穷大），则softmax后这里就置零了。如果忘记了请移步：</p><p><a href="https://www.notion.so/Transformer-c82afd9579ca4436afaeeacd3b0e5c67?pvs=21">Transformer</a></p><h2 id="6-Relative-Position-Bias"><a href="#6-Relative-Position-Bias" class="headerlink" title="6. Relative Position Bias"></a>6. Relative Position Bias</h2><p>就是在Attenton中添加了位置偏移信息，具体是通过MLP的bias实现，效果很玄学，公式如下：</p><p>$$<br>Attention&#x3D;SoftMax(\frac{QK^T}{\sqrt{d}}+B)V<br>$$</p><p>Note:w&#x2F;o是without的缩写，w&#x2F;是with的缩写</p><p>关于偏置B是如何实现的，见下文：</p><p>如图所示，对于位置在$(x_0,\ y_0)$的像素，它的绝对位置编码就是它本身的坐标，它关于$(x_1,\ y_1)$的相对位置坐标是$(x_0-x_1,\ y_0-y_1)$</p><p>则对于尺寸为$window\text{_}size$的窗口，每个位置都有对应的$window\text{_}size-1$个相对位置编码，将其拉成1维，重复计算其他位置可得如下$shape&#x3D;(window\text{_}size, window\text{_}size)$的Relative Position Table，Relative Position Table[window_size *x+y][:]是$(x,y)$位置关于其他位置的相对位置编码</p><p><img src="/images/picture6.png" alt="Untitled"></p><p>现在的问题是，如何去索引第二维，进而取出偏置？关于位置$(x_0,y_1)、(x_1, y_0)$，若直接两维相加，则映射在一维是等价的，实际二者的偏置信息存储在不同位置</p><p>首先需要将每个维度加上$window\text{_}size-1$，以保证偏移量从0开始（对于$size&#x3D;window\text{_}size$大小的窗口，最小偏移量就是$-window\text{_}size+1$）</p><p>然后对第一维做处理，对第一维乘以2倍的窗口大小减1，再进行两个维度的相加。这样就不会出现相同值的情况了，这样就得到了位置索引表</p><p>根据这张表，可以很方便的索引到一维的Relative Position Table表，该表是一张一维表，大小是$(2 * window\text{_}size-1)^2$。因为对于上述索引表，原始的最大偏置量即$2 * window\text{_}size - 2$，则可以计算最大一维映射偏置量为：<br>$$(2 * window\text{_}size - 2) * (2 * window\text{_}size - 1) + 2 * window\text{_}size - 2 &#x3D; (2 * window\text{_}size - 1)^2 - 1$$</p><p>则索引范围是$[0,(2*window\text{_}size-1)^2]$，即证</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建总结报告</title>
      <link href="/2024/04/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/04/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="博客概览"><a href="#博客概览" class="headerlink" title="博客概览"></a>博客概览</h2><p>本次作业中，我选择了“数据科学与技术分享”作为我的个人博客主题，旨在分享我在数据科学领域的学习心得、技术总结以及项目经验。博客基于Hexo静态网站生成器搭建，并部署在GitHub Pages上。</p><h2 id="技术汇报"><a href="#技术汇报" class="headerlink" title="技术汇报"></a>技术汇报</h2><h3 id="技术与工具"><a href="#技术与工具" class="headerlink" title="技术与工具"></a>技术与工具</h3><ul><li><strong>Hexo</strong>: 作为静态网站生成器，Hexo提供了快速的生成速度和灵活的插件系统。</li><li><strong>GitHub Pages</strong>: 利用GitHub Pages进行博客的托管，保证了网站的稳定性和访问速度。</li><li><strong>Markdown</strong>: 通过Markdown编写博客内容，保证了内容的可读性和编写效率。</li><li><strong>Cactus主题</strong>: 选择了Cactus主题，因为它简洁、响应式的设计非常适合个人博客。</li></ul><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul><li><strong>页面布局</strong>: 设计了首页、关于我、文章列表和文章详情等页面。</li><li><strong>导航菜单</strong>: 实现了一个清晰的导航菜单，方便用户浏览不同页面。</li><li><strong>代码高亮</strong>: 通过配置Cactus主题的代码高亮功能，使得代码块在博客中显示更加美观。</li><li><strong>社交链接</strong>: 在博客页脚添加了社交链接，便于读者关注和联系。</li></ul><h2 id="内容丰富度"><a href="#内容丰富度" class="headerlink" title="内容丰富度"></a>内容丰富度</h2><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><table><thead><tr><th>页面</th><th>内容</th></tr></thead><tbody><tr><td>首页</td><td>展示最新博客文章和简介，以及特色项目的展示。</td></tr><tr><td>关于我</td><td>个人介绍、教育背景、技能和获奖情况。</td></tr><tr><td>文章列表</td><td>展示所有博客文章的列表，支持分页。</td></tr><tr><td>文章详情</td><td>展示单篇文章的详细内容，包括文字、图片和代码块。</td></tr></tbody></table><h3 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h3><p>选择“数据科学与技术分享”作为博客主题，是因为我对数据科学领域充满热情，并且希望能够通过博客与他人分享我的知识和经验。</p><h2 id="博客制作过程中遇到的问题及其解决方法"><a href="#博客制作过程中遇到的问题及其解决方法" class="headerlink" title="博客制作过程中遇到的问题及其解决方法"></a>博客制作过程中遇到的问题及其解决方法</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><strong>问题描述</strong>: 在部署过程中，遇到了资源文件404错误。</p><p><strong>解决方法</strong>: 检查了文件路径和仓库结构，确保了资源文件位于正确的目录下，并且更新了GitHub Pages的设置。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p><strong>问题描述</strong>: 在配置代码高亮时，发现默认的颜色方案不符合博客的整体风格。</p><p><strong>解决方法</strong>: 通过修改<code>_config.yml</code>文件中的<code>highlight</code>配置项，选择了一个与博客主题相匹配的颜色方案。</p><h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>通过本次作业，我不仅学习了如何使用Hexo和GitHub Pages搭建个人博客，还加深了对静态网站和Markdown的理解。在制作博客的过程中，我意识到了良好的页面布局和内容组织对于用户体验的重要性。同时，我也认识到了在技术实践中遇到问题时，耐心和细致的排查是解决问题的关键。</p><p>在未来的博客维护中，我将继续优化博客的设计和内容，提高博客的可访问性和互动性，使其成为一个有价值的技术分享平台。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Legate Sparse论文总结报告</title>
      <link href="/2024/04/12/%20Legate%20Sparse%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/04/12/%20Legate%20Sparse%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Legate-Sparse-Distributed-Sparse-Computing-in-Python"><a href="#Legate-Sparse-Distributed-Sparse-Computing-in-Python" class="headerlink" title="Legate Sparse: Distributed Sparse Computing in Python"></a>Legate Sparse: Distributed Sparse Computing in Python</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>“Legate Sparse: Distributed Sparse Computing in Python” 是一篇介绍Legate Sparse系统的研究论文，该系统旨在透明地分布和加速基于SciPy的稀疏矩阵程序，并能够在CPU和GPU集群上执行。Legate Sparse与cuNumeric（一个分布式NumPy库）协同工作，使用静态和动态技术高效地组合稀疏和密集数组编程库，为分布式稀疏和密集数组计算提供统一的Python接口。研究表明，Legate Sparse在单GPU库（如CuPy）上具有竞争力，并在Summit超级计算机上达到1280个CPU核心和192个GPU的性能，同时提供idiomatic SciPy和NumPy的生产力优势。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python因其易用性和丰富的数值库生态系统而在数据科学、机器学习和科学计算中被广泛使用。特别是NumPy和SciPy库，它们分别用于密集和稀疏矩阵计算，是许多应用程序和框架的基础。然而，这些库的标准实现仅限于单个CPU节点，并且只有少数操作支持多线程。随着数据集大小和应用计算需求的增加，有必要利用超出单个CPU节点所能提供的更强大的资源。尽管最近的工作在密集数组编程系统方面取得了很大进展，但自动分布和加速基于SciPy的稀疏矩阵程序尚未实现。Legate Sparse的目标是开发一个系统，该系统能够在分布式机器上扩展未修改的SciPy Sparse程序，并与cuNumeric高效组合。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本节提供了有关SciPy Sparse模块的背景信息，并讨论了与本研究相关的库组件。此外，还介绍了Legion运行时系统，Legate Sparse和cuNumeric都是建立在该系统之上的。cuNumeric是一个分布式和加速的NumPy替代品，它通过动态将NumPy API转换为Legion任务来实现。</p><h2 id="稀疏数据表示"><a href="#稀疏数据表示" class="headerlink" title="稀疏数据表示"></a>稀疏数据表示</h2><p>Legate Sparse使用Legion的区域（regions）来表示稀疏矩阵，这些区域被划分为子区域以进行并行处理。通过Legion的图像（image）分区操作，Legate Sparse能够表达稀疏矩阵的共分区，并实现类似于MPI的散布&#x2F;聚集操作。</p><h2 id="可组合并行化"><a href="#可组合并行化" class="headerlink" title="可组合并行化"></a>可组合并行化</h2><p>Legate Sparse和cuNumeric通过将每个操作转换为一系列在分区区域上的任务启动来分布SciPy和NumPy程序。通过使用基于约束的并行化和动态运行时系统，Legate Sparse能够与cuNumeric在分布式层上高效组合。</p><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>Legate Sparse的原型实现了SciPy Sparse API的35%，足以表达科学计算和机器学习中的复杂计算。实现这些API的方法包括使用DISTAL编译器生成代码、从现有的SciPy或CuPy实现中移植代码，以及手写代码。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>Legate Sparse在Summit超级计算机上的性能通过一系列SciPy程序进行了评估，这些程序涵盖了从微基准测试到完整应用程序的不同复杂性。Legate Sparse在CPU和GPU模式下的性能都得到了测试，并与仅支持CPU或GPU的系统进行了比较。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>本节讨论了分布式稀疏线性代数和张量代数库、加速和分布式NumPy的相关研究工作。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Legate Sparse为分布和加速未修改的SciPy Sparse程序提供了一种解决方案，并与cuNumeric高效组合。Legate Sparse的开发解决了软件堆栈中的可组合性问题，并为开发高性能分布式库提供了一种模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ssh登录linux主机后无法访问外网的问题</title>
      <link href="/2023/04/08/%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95linux%E4%B8%BB%E6%9C%BA%E5%90%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/08/%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95linux%E4%B8%BB%E6%9C%BA%E5%90%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>简言之：我忘了export代理环境变量了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http_proxy</span></span><br><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line">export https_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存后</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清理docker容器日志</title>
      <link href="/2023/03/07/%E6%B8%85%E7%90%86docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
      <url>/2023/03/07/%E6%B8%85%E7%90%86docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="查看docker容器日志"><a href="#查看docker容器日志" class="headerlink" title="查看docker容器日志"></a>查看docker容器日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;======== docker containers logs file size ========&quot;  </span><br><span class="line"></span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log)  </span><br><span class="line"></span><br><span class="line">for log in $logs  </span><br><span class="line">        do  </span><br><span class="line">             ls -lh $log   </span><br><span class="line">        done  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +x docker_log_size.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./docker_log_size.sh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="清理日志"><a href="#清理日志" class="headerlink" title="清理日志"></a>清理日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span> </span><br><span class="line">  </span><br><span class="line">echo &quot;======== start clean docker containers logs ========&quot;  </span><br><span class="line">  </span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log)  </span><br><span class="line">  </span><br><span class="line">for log in $logs  </span><br><span class="line">        do  </span><br><span class="line">                echo &quot;clean logs : $log&quot;  </span><br><span class="line">                cat /dev/null &gt; $log  </span><br><span class="line">        done  </span><br><span class="line"></span><br><span class="line">echo &quot;======== end clean docker containers logs ========&quot;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +x clean_docker_log.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./clean_docker_log.sh</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/yjk13703623757/article/details/80283729">https://blog.csdn.net/yjk13703623757/article/details/80283729</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
